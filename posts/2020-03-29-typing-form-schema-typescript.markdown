---
title: Modeling a Form Schema in TypeScript
author: Peter Stuart
---

A field can be modeled as a [discriminated union][discriminated-union]:

```typescript
interface TextField {
  kind: 'textField'
}

interface NumberField {
  kind: 'numberField'
  min?: number
  max?: number
}

type Field = TextField | NumberField
```

... and a form can be modeled as a collection of fields:

```typescript
interface Form {
  fields: {
    [key: string]: Field
  }
}
```

Here's an example of a form conforming to this `Form` interface, which we'll use for the rest of this article:

```typescript
const form = {
  fields: {
    name: {
      kind: 'textField' as const,
    },
    age: {
      kind: 'numberField' as const,
      min: 0,
    },
  },
}
```

## Writing `FieldValue<T>` and `FormValues<T>`

It would be useful to know (at a type level) the type of values that will be generated for a `Form`. For our example form, we'd expect the type of its values to look like this:

```typescript
{
  name: string,
  age: number,
}
```

To be able to write a type which can derive that information from a form, we first need to be able to determine the type of value that will be generated for any `Field`. We can do that with a [conditional type][conditional-type]:

```typescript
type FieldValue<T extends Field> = T extends TextField ? string : number

type Foo = FieldValue<TextField> // string
type Bar = FieldValue<NumberField> // number
```

For comparison, look at the same logic written as a value-level function:

```typescript
const fieldValue = (field: Field) =>
  field.kind === 'textField' ? 'string' : 'number'

const foo = fieldValue({ kind: 'textField' }) // 'string'
const bar = fieldValue({ kind: 'numberField', min: 0 }) // 'number'
```

The `FieldValue` type and the `fieldValue` function work in the same way. They both:

- take a `Field` parameter
- if the field is a `TextField`, return `string`/`'string'`, otherwise return `number`/`'number'`

You can think of types which have type parameters as type-level functions:

| Type-Level   | Value-Level           |
| ----------   | -----------           |
| `T`          | a value               |
| `T<A>`       | `(a) => result`       |
| `T<A, B>`    | `(a, b) => result`    |
| `T<A, B, C>` | `(a, b, c) => result` |

Now we can write `FormValues<T>` as a [mapped type][mapped-type]:

```typescript
type FormValues<T extends Form> = {
  [fieldName in keyof T['fields']]: FieldValue<T['fields'][fieldName]>
}

type Baz = FormValues<typeof form> // { name: string, age: number }
```

The syntax might be unfamiliar, but the logic is straightforward. Here's the same logic written as a value-level function, using [`mapValues`][map-values] from [Lodash][lodash]:

```typescript
const formValues = (form: Form) =>
  mapValues(form.fields, field => fieldValue(field))

const baz = formValues(form) // { name: 'string', age: 'number' }
```

Once again, the two versions are very similar, just working at different levels, and with different syntaxes. They both iterate over all the keys in a `Form`'s `fields`, mapping over the values using `FieldValue`/`fieldValue`.

## Using `FormValues<T>`

Now that we know the type of values that will be produced for any given `Form`, we can take advantage of that by enforcing that any functions that operate on form values are compatible with the form that generated those values. For example, we can write a `FormUI` React component that accepts a `form` and an `onSubmit` function:

```typescript
interface FormUIProps<T extends Form> {
  form: T
  onSubmit: (values: FormValues<T>) => void
}

const FormUI: <T extends Form>(props: FormUIProps<T>) => (
  <form>
    ...
  </form>
)

const App = () => (
  <FormUI
    form={form}
    onSubmit={({ name, age }) => {
      // TypeScript knows the types of these values:
      // - name: string
      // - age: number
      console.log(name, age)
    }}
  />
)
```

Because `form` and `onSubmit` are related using the `T` type parameter, TypeScript knows the type of the values that will be used as the input to `onSubmit`. If we try to reference a value that won't actually be generated by the form, like `gender`:

```typescript
const App: FC = () => (
  <FormUI
    form={form}
    onSubmit={({ gender }) => {
      console.log(gender)
    }}
  />
)
```

... we get a compilation error[^verbose-error]:

[^verbose-error]: The error is unfortunately verbose because it expands the type of our `form` object.

`Property 'gender' does not exist on type 'FormValues<{ fields: { name: { kind: "textField"; }; age: { kind: "numberField"; min: number; }; }; }>'.`

## Going Further

Most forms need to support more than text and number fields, and the implementation of `FieldValue<T>` starts getting ugly once you get past a couple of field types:

```typescript
type FieldValue<T extends Field> = T extends TextField
  ? string
  : T extends NumberField
    ? number
    : T extends DateField
      ? Date
      : T extends ColorField
        ? Color
        : ...
```

Instead of nesting `extends`, you can use a `Switch`[^switch] type:

[^switch]: I wrote about [writing a type-level switch statement][switch] previously.

```typescript
type FieldValue<T extends Fields> = Switch<T, [
  [TextField, string],
  [NumberField, number],
  [DateField, Date],
  [ColorField, Color]
  ...
]> = ...
```

[discriminated-union]: https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions
[conditional-type]: https://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types
[mapped-type]: https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types
[map-values]: https://lodash.com/docs/4.17.15#mapValues
[lodash]: https://lodash.com
[switch]: /posts/2020-03-07-writing-type-level-switch-statement-typescript
