---
title: Modeling a Form Schema in TypeScript
author: Peter Stuart
---

A field can be modeled as a [[https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions][discriminated union]]:

#+BEGIN_SRC typescript
  interface TextField {
    kind: 'textField'
  }

  interface NumberField {
    kind: 'numberField'
    min?: number
    max?: number
  }

  type Field = TextField | NumberField
#+END_SRC

... and a form can be modeled as a collection of fields:

#+BEGIN_SRC typescript
  interface Form {
    fields: {
      [key: string]: Field
    }
  }
#+END_SRC

Here's an example of a form conforming to this ~Form~ interface, which we'll use for the rest of this article:

#+BEGIN_SRC typescript
  const form = {
    fields: {
      name: {
        kind: 'textField' as const,
      },
      age: {
        kind: 'numberField' as const,
        min: 0,
      },
    },
  } 
#+END_SRC

** Writing ~FieldValue<T>~ and ~FormValues<T>~

It would be useful to know (at a type level) the type of values that will be generated for a ~Form~. For our example form, we'd expect the type of its values to look like this:

#+BEGIN_SRC typescript
  {
    name: string,
    age: number,
  }
#+END_SRC

To be able to write a type which can derive that information from a form, we first need to be able to determine the type of value that will be generated for any ~Field~. We can do that with a [[https://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types][conditional type]]:

#+BEGIN_SRC typescript
  type FieldValue<T extends Field> = T extends TextField ? string : number

  type Foo = FieldValue<TextField> // string
  type Bar = FieldValue<NumberField> // number
#+END_SRC

For comparison, look at the same logic written as a value-level function:

#+BEGIN_SRC typescript
  const fieldValue = (field: Field) =>
    field.kind === 'textField' ? 'string' : 'number'

  const foo = fieldValue({ kind: 'textField' }) // 'string'
  const bar = fieldValue({ kind: 'numberField', min: 0 }) // 'number'
#+END_SRC

The ~FieldValue~ type and the ~fieldValue~ function work in the same way. They both:

- take a ~Field~ parameter
- if the field is a ~TextField~, return ~string~ / ~'string'~, otherwise return ~number~ / ~'number'~

You can think of types which have type parameters as type-level functions:

| Type-Level   | Value-Level           |
|--------------+-----------------------|
| ~T~          | a value               |
| ~T<A>~       | ~(a) => result~       |
| ~T<A, B>~    | ~(a, b) => result~    |
| ~T<A, B, C>~ | ~(a, b, c) => result~ |

Now we can write ~FormValues<T>~ as a [[https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types][mapped type]]:

#+BEGIN_SRC typescript
  type FormValues<T extends Form> = {
    [fieldName in keyof T['fields']]: FieldValue<T['fields'][fieldName]>
  }

  type Baz = FormValues<typeof form> // { name: string, age: number }
#+END_SRC

The syntax might be unfamiliar, but the logic is straightforward. Here's the same logic written as a value-level function, using [[ https://lodash.com/docs/4.17.15#mapValues][~mapValues~]] from [[https://lodash.com][Lodash]]:

#+BEGIN_SRC typescript
  const formValues = (form: Form) =>
    mapValues(form.fields, field => fieldValue(field))

  const baz = formValues(form) // { name: 'string', age: 'number' }
#+END_SRC

Once again, the two versions are very similar, just working at different levels, and with different syntaxes. They both iterate over all the keys in a ~Form~'s ~fields~, mapping over the values using ~FieldValue~ / ~fieldValue~.

** Using ~FormValues<T>~

Now that we know the type of values that will be produced for any given ~Form~, we can take advantage of that by enforcing that any functions that operate on form values are compatible with the form that generated those values. For example, we can write a ~FormUI~ React component that accepts a ~form~ and an ~onSubmit~ function:

#+BEGIN_SRC typescript
  interface FormUIProps<T extends Form> {
    form: T
    onSubmit: (values: FormValues<T>) => void
  }

  const FormUI: <T extends Form>(props: FormUIProps<T>) => (
    <form>
      ...
    </form>
  )

  const App = () => (
    <FormUI
      form={form}
      onSubmit={({ name, age }) => {
        // TypeScript knows the types of these values:
        // - name: string
        // - age: number
        console.log(name, age)
      }}
    />
  )
#+END_SRC

Because ~form~ and ~onSubmit~ are related using the ~T~ type parameter, TypeScript knows the type of the values that will be used as the input to ~onSubmit~. If we try to reference a value that won't actually be generated by the form, like ~gender~:

#+BEGIN_SRC typescript
  const App: FC = () => (
    <FormUI
      form={form}
      onSubmit={({ gender }) => {
        console.log(gender)
      }}
    />
  )
#+END_SRC

... we get a compilation error[fn:verbose-error]:

[fn:verbose-error] The error is unfortunately verbose because it expands the type of our ~form~ object.

#+BEGIN_SRC text
  Property 'gender' does not exist on type 'FormValues<{ fields: { name: { kind: "textField"; }; age: { kind: "numberField"; min: number; }; }; }>'.
#+END_SRC

** Going Further

Most forms need to support more than text and number fields, and the implementation of ~FieldValue<T>~ starts getting ugly once you get past a couple of field types:

#+BEGIN_SRC typescript
  type FieldValue<T extends Field> = T extends TextField
    ? string
    : T extends NumberField
      ? number
      : T extends DateField
        ? Date
        : T extends ColorField
          ? Color
          : ...
#+END_SRC

Instead of nesting ~extends~, you can use a ~Switch~[fn:switch] type:

[fn:switch] I wrote about [[/posts/2020-03-07-writing-type-level-switch-statement-typescript][writing a type-level switch statement]] previously.

#+BEGIN_SRC typescript
  type FieldValue<T extends Fields> = Switch<T, [
    [TextField, string],
    [NumberField, number],
    [DateField, Date],
    [ColorField, Color]
    ...
  ]>
#+END_SRC
